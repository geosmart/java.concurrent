chp2.线程安全性
---

<!-- TOC -->

- [什么是线程安全性](#什么是线程安全性)
- [原子性](#原子性)
    - [竞态条件(Race Condition)](#竞态条件race-condition)
    - [复合操作](#复合操作)
- [加锁机制](#加锁机制)
    - [内置锁](#内置锁)
    - [重入](#重入)
- [用锁来保护状态](#用锁来保护状态)
- [活跃性与性能](#活跃性与性能)

<!-- /TOC -->

>要编写线程安全的代码，其核心在于要对`状态`访问操作进行管理，特别是对`共享`（Shared）状态和`可变`（Mutable）状态的访问。
* `对象的状态`是指存储在状态变量（例如实例变量/静态域）中的数据，以及其他依赖对象的域；在对象的状态中包含了任何可能影响其外部可见行为的数据；
* `共享`意味着变量可以由多个线程同时访问；
* `可变`意味着变量的值在其生命周期内可以发生变化；

一个对象是否需要是线程安全的，取决于它是否被多个线程同时访问。
当多个线程访问某个状态变量并且其中一个线程在执行写入操作时，可以采用三种方式避免线程安全性问题：
1. 不在线程之间共享该状态变量；
2. 将状态变量改为不可变的变量；
3. 采用`同步机制`来协同这些状态变量的访问；

# 什么是线程安全性
1. 正确性：将单线程的正确性近似定义为`所见即所知`(we know it when we see it)；
2. 安全性：当多线程访问某个类时，不管`运行时`环境采用何种`调度`方式或者这些线程如何`交替执行`，并且在`主调代码`中不需要任何额外的`同步`或`协同`，这个类始终都能表现出`正确的行为`，那么就称这个类是线程安全的；
3. 无状态对象一定是线程安全的
4. 大多数Servlet都是无状态的，从而极大的降低了在实现Servlet线程安全性时的复杂性；

# 原子性
在并发编程中，由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件（Race Condition）.
## 竞态条件(Race Condition)
1. 当某个计算的正确性取决于多个线程的交替执行时，就会发生竞态条件，即正确的结果取决于运气；
2. 最常见的竞态条件类型是`先检查后执行（Check-Then-Act）`操作，即通过一个可能失效的观测结果来决定下一步的动作；
3. 使用`Check-Then-Act`的一种常见情况就是`延迟初始化`（LazyInitRace）。延迟初始化的目的是将对象的初始化推迟到实际被使用时才进行，同时要确保只被初始化一次，如单例模式；
4. 在`读取-修改-写入`这种操作（例如递增一个计数器）中，基于对象之前的状态来定义对象状态的转换。要递增一个计数器，必须知道它`之前的值`，并确保在执行`更新`的过程中没有其他线程会`修改`或`使用`这个值。

## 复合操作
将先`检查后执行`以及`读取-修改-写入`等操作统称为复合操作，包含了一组必须以`原子`方式执行的操作以确保线程安全性。

# 加锁机制
## 内置锁
Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）；
1. 同步代码块包含2部分：1个作为锁的对象引用； 1个作为这个锁保护的代码块；
2. 以关键字Synchronized修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是`方法调用所在的对象`；
3. 静态的synchronized方法以Class对象为锁；
4. Java的内置锁相当于一种互斥锁（Mutex），这意味着最多只有一个线程持有这种锁；
5. 由于每次只有1个线程执行内置锁保护的代码块，因此由这个`锁`保护的`同步代码块`会以`原子`方式执行，多个线程在执行该代码时也不会互相干扰；

## 重入
当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然后，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。
1. `重入`意味着获取锁的操作粒度是`线程`。而不是调用；
2. 重入进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发；
3. 重入避免了一些死锁情况的发生（如重写父类的Synchronized方法）；

# 用锁来保护状态
对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的；
1. 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁；
2. 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护；

# 活跃性与性能
1. 要判断同步代码块的合理大小，需要在各种设计需求之间进行平衡，包括安全性（必须满足）、简单性和性能；
2. 通常，在简单性和性能之间存在着相互制约的因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）；
3. 当执行时间较长的计算或者可能无法快速完成的操作时（如网络I/O或控制台I/O），一定不要持有锁；