任务执行
---
>大多数并发应用程序都是围绕`任务执行（Task Execution）`来构造的：
任务通常是抽象的且离散的工作单元，通过把应用程序的工作分解到多个任务中，可以`简化程序的组织结构`，
提供一种`自然的事务边界`来`优化错误的恢复过程`，
提供一种`自然的并行工作结构`来提升`并发性`；
>
<!-- TOC -->

- [在线程中执行任务](#在线程中执行任务)
    - [串行的执行任务](#串行的执行任务)
    - [显式的为任务创建线程](#显式的为任务创建线程)
    - [无限制创建线程的不足](#无限制创建线程的不足)
- [Executor框架](#executor框架)
    - [示例：基于Executor的web服务器](#示例基于executor的web服务器)
    - [执行策略](#执行策略)
    - [线程池](#线程池)
    - [Executor的生命周期](#executor的生命周期)
    - [延迟任务与周期任务](#延迟任务与周期任务)
- [找出可利用的并行性](#找出可利用的并行性)
    - [示例：串行的页面渲染器](#示例串行的页面渲染器)
    - [携带结果的任务Callable与Future](#携带结果的任务callable与future)
    - [示例：使用Future实现页面渲染器](#示例使用future实现页面渲染器)
    - [在异构任务并行化中存在的局限](#在异构任务并行化中存在的局限)
    - [CompletionService:Executor与BlockingQueue](#completionserviceexecutor与blockingqueue)
    - [示例：使用CompletionService实现页面渲染器](#示例使用completionservice实现页面渲染器)
    - [示例：旅行预订门户网站](#示例旅行预订门户网站)

<!-- /TOC -->

# 在线程中执行任务
1. 当围绕`任务执行`来设计应用程序结构时，第一步就是要找出清晰的任务边界；
    * 在理想情况下，各个任务之间是相互独立的：任务并不依赖其他任务的状态、结果或边界效应；
    * 独立性有助于实现并发；
    * 在正常负载下，服务器应用程序应该同时表现出良好的吞吐量和快速的响应性；
    * 当负荷过载时，应用程序的性能应该是逐渐降低，而不是直接失败；
    * 大多数服务器应用程序都是提供了一种自然的任务边界选择放手：以独立的客户请求为边界；
2. 第二步就是有明确的任务执行策略；
## 串行的执行任务
1. 在应用程序中可以通过多种策略来调度任务，而其中一些策略能够更好的利用潜在的并发性；
2. 最简单的策略就是在单个线程中串行的执行各项任务；
3. 在服务器应用程序中，串行处理程序通常都无法提供高吞吐率或快速响应性；服务器的资源利用率非常低，因为当单线程在等待I/O操作完成时，CPU将处于空闲状态；
## 显式的为任务创建线程
1. 为每个请求创建一个线程来提供服务，从而实现更高的响应性；
* 任务处理过程从`主线程`中分离出来，使得主循环能够更快的重新等待下一个到来的连接，这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性；
* 任务可以`并行处理`，从而能同时服务多个请求。如果有多个服务器，或者由于某种原因被阻塞，例如`等待I/O完成`、`获取锁`或者`资源可用性`等，程序的吞吐量将得到提高；
* `任务处理代码必须是线程安全的`，因为有多个线程会并发的调用这段代码；
2. 在正常负载情况下,`为每个任务分片一个线程`的方法能提升串行执行的性能。只要`请求的到达率`不超过服务器的请求`处理能力`，那么这种方法可以同时带来更快的`响应性`和更高的`吞吐率`；
## 无限制创建线程的不足
在生产环境，为`每个任务分配一个线程`这种方法存在一些缺陷，尤其是需要创建大量线程时：
1. 线程生命周期的开销非常高：创建和销毁有时间代价；
2. 资源消耗：活跃的线程会消耗系统资源，尤其是内存；
    * 如果可运行的线程数量多于可用处理器的数量，那么有些线程将会闲置；
    * 大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。
    * 如果你已经拥有足够多的线程使CPU保持忙碌状态，那么再创建更多的线程反而会降低性能；
3. 稳定性：在可创建线程的数量上存在一个线程，这个限制值将随着平台的不同而不同，并且受多个因素制约，包括JVM启动参数、Thread构造函数中请求的栈的大小，以及底层操作系统对线程的限制等；
4. 安全性；某个恶意用户或者过多的用户请求将使得服务器过载，过多的创建线程导致服务崩溃；

# Executor框架
1. 任务是一组逻辑工作单元，而线程则是使任务异步执行的机制；
2. 在Java类库中，任务执行的主要抽象不是Thread，而是Executor
```java
public interface Executor{
    void execute(Runnable command);
}
```
3. Executor提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。
4. Executor的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视机制；
5. Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的操作相当于消费者；

## 示例：基于Executor的web服务器
## 执行策略
## 线程池
## Executor的生命周期
## 延迟任务与周期任务

# 找出可利用的并行性
## 示例：串行的页面渲染器
## 携带结果的任务Callable与Future
## 示例：使用Future实现页面渲染器
## 在异构任务并行化中存在的局限
## CompletionService:Executor与BlockingQueue
## 示例：使用CompletionService实现页面渲染器
## 示例：旅行预订门户网站