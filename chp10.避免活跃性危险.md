避免活跃性危险
---
>在安全性与活跃性之间通常存在着某种制衡。我们使用加锁机制来确保线程安全，但如果过度使用加锁，则可能导致锁顺序死锁（Lock-Ordering DeadLock）。
>同样，我们使用线程池和信号量来限制对资源的使用，但这些限制的行为可能会导致资源死锁（Resource Deadlock）。
>Java应用程序无法从死锁中国恢复过来，因此在设计时一定要排除那些可能导致死锁出现的条件。
>本章将结束一些导致活跃性故障的原因，以及如何避免他们。

<!-- TOC -->

- [死锁](#死锁)
    - [锁顺序死锁](#锁顺序死锁)
    - [动态的锁顺序死锁](#动态的锁顺序死锁)
    - [在协作对象之间发生的死锁](#在协作对象之间发生的死锁)
    - [开放调用](#开放调用)
    - [资源死锁](#资源死锁)
- [死锁的避免与诊断](#死锁的避免与诊断)
    - [支持定时的锁](#支持定时的锁)
    - [通过线程转储来分析死锁](#通过线程转储来分析死锁)
- [其他活跃性危险](#其他活跃性危险)
    - [饥饿](#饥饿)
    - [糟糕的响应性](#糟糕的响应性)
    - [活锁](#活锁)

<!-- /TOC -->
# 死锁
## 锁顺序死锁
## 动态的锁顺序死锁
## 在协作对象之间发生的死锁
## 开放调用
## 资源死锁

# 死锁的避免与诊断
## 支持定时的锁
## 通过线程转储来分析死锁
# 其他活跃性危险
## 饥饿
## 糟糕的响应性
## 活锁