取消与关闭
---
>任务和线程的启动很容易，但是如何`安全、快速、可靠`的`停止`下来？
>生命周期结束（`End-of-LifeCycle`）的问题会使任务、服务以及程序的设计和实现等过程变得复杂，而这个在程序设计中非常重要的要素却经常被忽略。
>一个在行为良好的软件与勉强运行的软件之家的最主要的区别就是，行为良好的软件能很完善的处理失败、关闭和取消等过程；
>本章将给如各种实现`取消`和`中断`的机制，以及如何编写任务和服务，使他们能对取消请求做出响应；
<!-- TOC -->

- [任务取消](#任务取消)
    - [中断](#中断)
    - [中断策略（interruption Policy）](#中断策略interruption-policy)
    - [响应中断](#响应中断)
    - [示例：计时运行](#示例计时运行)
    - [通过Future来实现取消](#通过future来实现取消)
    - [处理不可中断的阻塞](#处理不可中断的阻塞)
    - [采用newTaskFor来封装非标准的取消](#采用newtaskfor来封装非标准的取消)
- [停止基于线程的服务](#停止基于线程的服务)
    - [示例：日志服务](#示例日志服务)
    - [关闭ExecutorService](#关闭executorservice)
    - [`毒丸`对象](#毒丸对象)
    - [示例：只执行一次的服务](#示例只执行一次的服务)
    - [shutdownNow的局限性](#shutdownnow的局限性)
- [处理非正常的线程终止](#处理非正常的线程终止)
- [JVM关闭](#jvm关闭)
    - [关闭钩子](#关闭钩子)
    - [守护线程](#守护线程)
    - [终结器](#终结器)
- [小结](#小结)

<!-- /TOC -->
# 任务取消
1. 如果外部代码能在某个操作正常完成之前将其置入`完成`状态，那么这个操作就可以称为可取消的（Cancellable）。
2. 取消某个操作的原因很多：
    * `用户请求取消`：API/GUI主动取消；
    * `有时间限制的操作`：超时取消操作；
    * `应用程序事件`：并行搜索问题，1个任务找到结果，其他任务取消；
    * `错误`：爬虫搜索时，某个任务检测到磁盘满，所有任务都将取消，并记录状态，以便稍后重启恢复；
    * `关闭`：程序关闭时，必须对正在处理或等待处理的任务执行某种操作，在`平缓的关闭过程`中，当前正在执行的任务将继续执行直到完成，而在`关闭过程`中，当前的任务则可能取消；
3. Java中没有一种安全的`抢占式方法`来`停止线程`，因此也就没有安全的抢占式方法来`停止任务`，只有一些`协作式机制`，使请求取消的任务和代码都遵循一种协商好的协议；
4. 其中一种协作机制能设置某个`已请求取消（Cancellation Requeste）`标志，而任务将定期的查看该标志。如果设置该标志，那么任务将提前结束；
5. 一个可取消任务必须拥有取消策略（Cancellation Policy）,在这个策略中将详细的定义取消操作的How、When和What
    * 其他代码如何（How）请求取消该任务；
    * 任务在何时（When）检查是否已经请求了取消；
    * 在响应取消请求时应执行哪些（What）操作；
## 中断
1. 不可靠的取消操作将把生产者置于阻塞操作中，任务将无法取消；
2. 每个线程都有一个boolean类型的中断状态。当中断线程时，这个线程的中断状态将被设置为ture;
```java
public class Thread{
    //中断目标线程
    public void interrupt(){}
    //返回目标线程的中断状态
    public boolean isInterrupted(){}
    //清除当前线程的中断状态,并返回它之前的值，这也是清除中断状态的唯一方法
    public static boolean interrupted(){}
}
```
3. 阻塞库方法，如`Thread.sleep`和`Object.wait`等，都会检查线程何时中断，并且在发现中断时提前返回，它们在响应中断时执行的操作包括：`清除中断状态`，`抛出InterruptedException`，表示阻塞操作由于中断而提前结束；
4. 调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息，由线程在下一个合适的时刻（取消点）中断自己；
5. ` wait,sleep,join`等方法将严格的处理中断请求；当它们收到中断请求或者在开始执行时发现某个已被设置好的中断状态时，将抛出一个异常；
6. 在使用静态的interuppted方法时应该小心，因为它会清除当前线程的中断状态。如果interrupted调用返回了true，那么除非你想屏蔽这个中断，否则必须对它进行处理，可以抛出interruptedException或者通过再次调用interrupted来恢复中断状态；
7. 通常，`中断是实现取消的最合理方式`；
```java
class PrimeProducer extends Thread{
    private final BlockingQueue<BigInteger> queue;

    PrimeProducer(BlockingQueue<BigInteger> queue){
        this.queue=queue;
    }

    public void run(){
        try {
            BigInteger p=BigInteger.one;
            while(!Thread.currentThread().isInterrupted()){
                queu.put(p=p.nextProbablePrime());
            }
        } catch (InterruptedException consumed) {
            //允许线程退出
        }
    }

    public void cancel(){
        interrupt();
    }
}
```

## 中断策略（interruption Policy）
1. 正如需要为任务制定任务取消策略一样，也应该制定线程的中断策略；
2. 一个中断策略决定线程如何面对中断请求:
    * 当发现中断请求时，它会做什么；
    * 哪些工作单元对于中断来说是原子操作；
    * 在多快的时间内响应中断；
3. 中断策略中最有意义的是对线程级（thread-level）和服务级（service level）取消的规定：
    * 尽可能`快速退出`，
    * 如果需要的话进行`清理`，
    * 可能的话`通知`其拥有的实体，这个线程已经退出；
    * 很可能建立其他中断策略，比如`暂停和重新开始`，但是那些具有非标准中断策略的线程或线程池，需要被约束于那些应用了该策略的任务中；
4. 区分任务和线程对中断的反应是很重要的。
* 一个单一的中断请求可能有一个或一个以上的预期的接收者；
* 在线程池中中断一个工作者线程，意味着取消当前任务，并关闭线程；
5. 任务不会再自己拥有的线程中执行：他们借用服务的线程，比如线程池；
6. 代码如果并不是线程的拥有者，就应该小心的保存中断状态，这样所有者的代码才能最终对其起到作用；
7. 为什么大多数可阻塞的库函数，仅仅抛出InterruptedException作为中断的响应？
他们绝不可能自己运行在一个线程中，所以他们为任务或者库代码实现了大多数合理的取消策略：它们会尽可能快的为异常信息让路，把它们向后传给调用者，这样上层栈的代码就可以进一步行动了；
8. 当检查到中断请求时候，任务并不需要放弃所有事情，它可以选择推迟，直到更合适的时机：这就需要记住她已经被请求过中断，完成当前正在卞的任务，然后排除InterruptedException或指明中断。当更新的过程发生中断时，这项技术能够`保证数据结构不被彻底破坏`；
9. 一个任务不应该假设其执行线程的中断策略，除非任务显式的设计用来运行在服务中，并且这些服务有明确的中断策略；
10. 无论任务把中断解释为取消，还是其他的一些关于中断的操作，它都应该注意保存执行线程的中断状态；如果对中断的处理不仅仅是把InterruptedException传递给调用者，那么它应该在捕获InterruptedException之后恢复中断的状态；
`Thread.currentThread().interrupt();`
11. 正常任务代码不应该假设猜测中断对于它的执行策略意味着什么，取消代码也不应该对任何线程的中断策略进行假设；线程应该只能够被线程的所有者中断；所有者可以把线程的中断策略信息封装到一个`合适的取消机制`中，比如`关闭（shutdown）`方法；
12. `因为每一个线程都有自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么`；
13. 批评者嘲笑Java的中断工具，因为它没有提供优先中断的能力，而且还强迫开发者处理InterruptedException。但是`推迟中断请求的能力`使开发者能够制定`更灵活的中断策略`，从而实现适合于程序的`响应性`和`健壮性`之间的平衡；
## 响应中断
1. 当调用可中断的阻塞函数时，比如Thread.sleep或者blockingQueue.put,有2种处理InterruptedException的实用策略：
    * 传递异常（很可能发生在特定任务的清除时），使你的方法也成为可中断的阻塞方法；
    * 保存中断状态，上层调用栈中的代码能够对其进行处理；
2. 只有实现了线程中断策略的代码才可以接收中断请求，通用目的的任务和库的代码绝不应该接收中断请求；
## 示例：计时运行

## 通过Future来实现取消
## 处理不可中断的阻塞
## 采用newTaskFor来封装非标准的取消

# 停止基于线程的服务
## 示例：日志服务
## 关闭ExecutorService
## `毒丸`对象
## 示例：只执行一次的服务
## shutdownNow的局限性

# 处理非正常的线程终止
# JVM关闭
## 关闭钩子
## 守护线程
## 终结器

# 小结
