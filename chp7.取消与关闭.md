取消与关闭
---
>任务和线程的启动很容易，但是如何`安全、快速、可靠`的`停止`下来？
>生命周期结束（`End-of-LifeCycle`）的问题会使任务、服务以及程序的设计和实现等过程变得复杂，而这个在程序设计中非常重要的要素却经常被忽略。
>一个在行为良好的软件与勉强运行的软件之家的最主要的区别就是，行为良好的软件能很完善的处理失败、关闭和取消等过程；
>本章将给如各种实现`取消`和`中断`的机制，以及如何编写任务和服务，使他们能对取消请求做出响应；
<!-- TOC -->

- [任务取消](#任务取消)
    - [中断](#中断)
    - [中断策略](#中断策略)
    - [响应中断](#响应中断)
    - [示例：计时运行](#示例计时运行)
    - [通过Future来实现取消](#通过future来实现取消)
    - [处理不可中断的阻塞](#处理不可中断的阻塞)
    - [采用newTaskFor来封装非标准的取消](#采用newtaskfor来封装非标准的取消)
- [停止基于线程的服务](#停止基于线程的服务)
    - [示例：日志服务](#示例日志服务)
    - [关闭ExecutorService](#关闭executorservice)
    - [`毒丸`对象](#毒丸对象)
    - [示例：只执行一次的服务](#示例只执行一次的服务)
    - [shutdownNow的局限性](#shutdownnow的局限性)
- [处理非正常的线程终止](#处理非正常的线程终止)
- [JVM关闭](#jvm关闭)
    - [关闭钩子](#关闭钩子)
    - [守护线程](#守护线程)
    - [终结器](#终结器)
- [小结](#小结)

<!-- /TOC -->
# 任务取消
1. 如果外部代码能在某个操作正常完成之前将其置入`完成`状态，那么这个操作就可以称为可取消的（Cancellable）。
2. 取消某个操作的原因很多：
    * `用户请求取消`：API/GUI主动取消；
    * `有时间限制的操作`：超时取消操作；
    * `应用程序事件`：并行搜索问题，1个任务找到结果，其他任务取消；
    * `错误`：爬虫搜索时，某个任务检测到磁盘满，所有任务都将取消，并记录状态，以便稍后重启恢复；
    * `关闭`：程序关闭时，必须对正在处理或等待处理的任务执行某种操作，在`平缓的关闭过程`中，当前正在执行的任务将继续执行直到完成，而在`关闭过程`中，当前的任务则可能取消；
3. Java中没有一种安全的`抢占式方法`来`停止线程`，因此也就没有安全的抢占式方法来`停止任务`，只有一些`协作式机制`，使请求取消的任务和代码都遵循一种协商好的协议；
4. 其中一种协作机制能设置某个`已请求取消（Cancellation Requeste）`标志，而任务将定期的查看该标志。如果设置该标志，那么任务将提前结束；
5. 一个可取消任务必须拥有取消策略（Cancellation Policy）,在这个策略中将详细的定义取消操作的How、When和What
    * 其他代码如何（How）请求取消该任务；
    * 任务在何时（When）检查是否已经请求了取消；
    * 在响应取消请求时应执行哪些（What）操作；
## 中断
## 中断策略
## 响应中断
## 示例：计时运行
## 通过Future来实现取消
## 处理不可中断的阻塞
## 采用newTaskFor来封装非标准的取消

# 停止基于线程的服务
## 示例：日志服务
## 关闭ExecutorService
## `毒丸`对象
## 示例：只执行一次的服务
## shutdownNow的局限性

# 处理非正常的线程终止
# JVM关闭
## 关闭钩子
## 守护线程
## 终结器

# 小结
