chp3.对象的共享
---
<!-- TOC -->

- [可见性](#可见性)
    - [失效数据](#失效数据)
    - [非原子的64位操作](#非原子的64位操作)
    - [加锁与可见性](#加锁与可见性)
    - [Volatile变量](#volatile变量)
- [发布与逸出（Publish & Escpae）](#发布与逸出publish--escpae)
- [线程封闭（Thread Confinement）](#线程封闭thread-confinement)
    - [Ad-hoc线程封闭](#ad-hoc线程封闭)
    - [栈封闭](#栈封闭)
    - [ThreadLocal类](#threadlocal类)
- [不变性](#不变性)
    - [Final域](#final域)
    - [使用Volatile类型来发布不可变对象](#使用volatile类型来发布不可变对象)
- [安全发布](#安全发布)
    - [不正确的发布：正确的对象被破坏](#不正确的发布正确的对象被破坏)
    - [不可变对象与初始化安全性](#不可变对象与初始化安全性)
    - [安全发布的常用模式](#安全发布的常用模式)
    - [事实不可变对象](#事实不可变对象)
    - [可变对象](#可变对象)
    - [安全的共享对象](#安全的共享对象)

<!-- /TOC -->
# 可见性
1. 为了确保多个线程对内存写入操作的可见性，必须使用同步操作；
2. 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论；
## 失效数据
除非在每次访问变量时都进行同步，否则可能获得该变量的一个失效值；
## 非原子的64位操作
1. 最低安全性（out-oft-thin-air-safety）：失效数据是之前某个线程设置的值，而不是一个随机值。这种安全性保证被称之为最低安全性；
2. 最低安全性适用于大多数变量，但是非volatile类型的64位数值变量（long和double）例外；
3. 对于`非volatile类型的long和double变量`，JVM允许将64位的读操作和写操作分解为两个32位的操作。如果对该变量的读操作和写操作在不同的线程中进行，那么很可能会读取到某个值的高32位和另一个值的低32位；
4. 即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非使用volatile关键字声明它们，或者用锁保护起来；
## 加锁与可见性
1. 内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果；
2. 为了确保某个线程写入该变量的值对其他线程可见，要求所有线程在`同一个锁上同步`；否则，一个线程在未持有正确锁的情况下读取到某个变量值，那么读到的可能是一个失效值；
## Volatile变量
1. volatile变量不会与其他内存操作一起重排序，也不会被缓存在寄存器或者其他处理器不可见的地方.因此在读取volatile类型的变量时`总是会返还最新写入的值`；
2. 在访问volatile变量时不会执行加锁操作（即不阻塞线程），因此volatile变量是一种比synchronized关键字`更轻量级的同步机制`；
3. 从内存可见性的角度来看，`写入volatile变量相当于退出同步代码块`，而`读取volatile变量相当于进入代码同步块`；
4. volatile变量的一种典型用法：`检查某个状态标记以判断是否退出循环`；
5. 加锁机制即可以确保可见性又可以保证原子性，而volatile变量`只能确保可见性`；
6. 当且仅当满足以下条件，才应该使用volatile变量：
    1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值；
    2. 该变量不会与其他状态变量一起纳入不变性条件中；
    3. 在访问变量时不需要加锁；

# 发布与逸出（Publish & Escpae）
1. 发布一个对象的意思是指，使对象能够在当前作用域之外的代码中使用； 
2. 如果在对象构造完成之前就发布该对象，就会破坏线程安全性。
3. 当某个不应该发布的对象被发布时，这种情况就被称为`逸出`（Escape）。
4. 当某个对象逸出后，必须假设有某个类或线程可能会误用它。这正是需要使用`封装`的最主要的原因：封装能使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难；
5. 安全的对象构造过程
    1. 不要在构造过程中使`this引用逸出`（构造函数中的创建的显式或隐式的线程会被新创建的线程共享），所以最好不要立即启动线程，而应该通过一个start或initialize方法来启动；
    2. 如果想在构造函数中启动一个线程或注册一个事件监听器，可以使用一个`私有的构造函数`和一个`公共的
    3. 工厂方法`（FactoryMethod），从而避免不正确的构造过程；

# 线程封闭（Thread Confinement）
1. 当访问共享的可变数据时，通常需要使用同步。一种避免同步的方式就是不共享数据；
2. 如果近在单线程内访问数据，就不需要同步，这种技术被称为线程封闭（Thread Confinement），它是实现线程安全性的最简单的方法之一；
3. Swing中大量使用了线程封闭技术，Swing的可视化组件和数据模型组件都不是线程安全的，Swing通过将它们封闭到`事件分发线程`中来实现线程安全性；
4. JDBC的Connection对象也常使用线程封闭技术：Connection对象在返回前，连接池不会将它分配给其他线程，这种连接管理模式在处理请求时隐含的将Connection对象封闭在线程中； 
## Ad-hoc线程封闭
## 栈封闭
## ThreadLocal类

# 不变性
## Final域
## 使用Volatile类型来发布不可变对象

# 安全发布
## 不正确的发布：正确的对象被破坏
## 不可变对象与初始化安全性
## 安全发布的常用模式
## 事实不可变对象
## 可变对象
## 安全的共享对象
