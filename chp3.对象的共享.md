chp3.对象的共享
---
<!-- TOC -->

- [可见性](#可见性)
    - [失效数据](#失效数据)
    - [非原子的64位操作](#非原子的64位操作)
    - [加锁与可见性](#加锁与可见性)
    - [Volatile变量](#volatile变量)
- [发布与逸出（Publish & Escpae）](#发布与逸出publish--escpae)
- [线程封闭（Thread Confinement）](#线程封闭thread-confinement)
    - [Ad-hoc线程封闭](#ad-hoc线程封闭)
    - [栈封闭](#栈封闭)
    - [ThreadLocal类](#threadlocal类)
- [不变性](#不变性)
    - [Final域](#final域)
    - [使用Volatile类型来发布不可变对象](#使用volatile类型来发布不可变对象)
- [安全发布](#安全发布)
    - [不正确的发布：正确的对象被破坏](#不正确的发布正确的对象被破坏)
    - [不可变对象与初始化安全性](#不可变对象与初始化安全性)
    - [安全发布的常用模式](#安全发布的常用模式)
    - [事实不可变对象](#事实不可变对象)
    - [可变对象](#可变对象)
    - [安全的共享对象](#安全的共享对象)

<!-- /TOC -->

# 可见性
1. 为了确保多个线程对内存写入操作的可见性，必须使用同步操作；
2. 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论；
## 失效数据
除非在每次访问变量时都进行同步，否则可能获得该变量的一个失效值；
## 非原子的64位操作
1. 最低安全性（out-oft-thin-air-safety）：失效数据是之前某个线程设置的值，而不是一个随机值。这种安全性保证被称之为最低安全性；
2. 最低安全性适用于大多数变量，但是非volatile类型的64位数值变量（long和double）例外；
3. 对于`非volatile类型的long和double变量`，JVM允许将64位的读操作和写操作分解为两个32位的操作。如果对该变量的读操作和写操作在不同的线程中进行，那么很可能会读取到某个值的高32位和另一个值的低32位；
4. 即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非使用volatile关键字声明它们，或者用锁保护起来；
## 加锁与可见性
1. 内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果；
2. 为了确保某个线程写入该变量的值对其他线程可见，要求所有线程在`同一个锁上同步`；否则，一个线程在未持有正确锁的情况下读取到某个变量值，那么读到的可能是一个失效值；
## Volatile变量
1. volatile变量不会与其他内存操作一起重排序，也不会被缓存在寄存器或者其他处理器不可见的地方.因此在读取volatile类型的变量时`总是会返还最新写入的值`；
2. 在访问volatile变量时不会执行加锁操作（即不阻塞线程），因此volatile变量是一种比synchronized关键字`更轻量级的同步机制`；
3. 从内存可见性的角度来看，`写入volatile变量相当于退出同步代码块`，而`读取volatile变量相当于进入代码同步块`；
4. volatile变量的一种典型用法：`检查某个状态标记以判断是否退出循环`；
5. 加锁机制即可以确保可见性又可以保证原子性，而volatile变量`只能确保可见性`；
6. 当且仅当满足以下条件，才应该使用volatile变量：
    1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值；
    2. 该变量不会与其他状态变量一起纳入不变性条件中；
    3. 在访问变量时不需要加锁；

# 发布与逸出（Publish & Escpae）
1. 发布一个对象的意思是指，使对象能够在当前作用域之外的代码中使用； 
2. 如果在对象构造完成之前就发布该对象，就会破坏线程安全性。
3. 当某个不应该发布的对象被发布时，这种情况就被称为`逸出`（Escape）。
4. 当某个对象逸出后，必须假设有某个类或线程可能会误用它。这正是需要使用`封装`的最主要的原因：封装能使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难；
5. 安全的对象构造过程
    1. 不要在构造过程中使`this引用逸出`（构造函数中的创建的显式或隐式的线程会被新创建的线程共享），所以最好不要立即启动线程，而应该通过一个start或initialize方法来启动；
    2. 如果想在构造函数中启动一个线程或注册一个事件监听器，可以使用一个`私有的构造函数`和一个`公共的
    3. 工厂方法`（FactoryMethod），从而避免不正确的构造过程；

# 线程封闭（Thread Confinement）
1. 当访问共享的可变数据时，通常需要使用同步。一种避免同步的方式就是不共享数据；
2. 如果近在单线程内访问数据，就不需要同步，这种技术被称为线程封闭（Thread Confinement），它是实现线程安全性的最简单的方法之一；
3. Swing中大量使用了线程封闭技术，Swing的可视化组件和数据模型组件都不是线程安全的，Swing通过将它们封闭到`事件分发线程`中来实现线程安全性；
4. JDBC的Connection对象也常使用线程封闭技术：Connection对象在返回前，连接池不会将它分配给其他线程，这种连接管理模式在处理请求时隐含的将Connection对象封闭在线程中； 
## Ad-hoc线程封闭
1. Ad-hoc线程封闭是指，维护线程封闭性的职责完全由和程序实现来控制。
2. Ad-hoc线程封闭非常脆弱，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程中；
3. 在某些情况下，单线程子系统提供的`简便性`要胜过Ad-hoc线程封闭技术的`脆弱性`；
4. `volatile变量`上存在一种特殊的线程封闭：只要能确保只有`单个线程`对共享的volatile变量执行`写入`操作(防止发生竞态条件)，那么就可以安全的将这些共享的volatile变量上执行`读取-修改-写入`的操作；
5. 由于Ad-hoc线程封闭的脆弱性，在程序中应该尽量少用；而应该使用更强的线程封闭技术（如栈封闭或ThreadLocal类）；

## 栈封闭
1. 栈封闭是线程封闭的一个特例；在栈封闭中，只有通过`局部变量`才能访问对象。
2. 局部变量的固有属性之一就是封闭在执行线程中，他们位于执行线程的栈中，其他线程无法访问这个栈；
3. 由于`任何方法都无法获得对基本类型的引用`，因此Java语言的这种语义就确保了`基本类型`的`局部变量`始终封闭在线程内；
4. 在线程内部上下文使用非线程安全的对象，那么该对象仍然是线程安全的；

## ThreadLocal类
1. 维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来；
2. ThreadLocal提供了get/set等访问接口，这些方法为每个使用该变量的线程都存有一份独立的副本；
3. ThreadLocal对象通常用于防止对可变的`单实例变量`（Singleton）或`全局变量`进行共享；
4. ThreadLocal<T>可视为包含了Map<Thread,T>对象；
5. 如单线程应用程序中可能会维护1个全局的数据库连接，但jdbc数据库连接对象不一定是线程安全的，因此将jdbc的连接保存在Threadlocal对象中，每个线程都会拥有自己的连接；
6. 假如需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象（若全局变量的语义允许），可以维护线程安全性；
7. ThreadLocal类似于`全局变量`，它会降低代码的`可重用性`，并在类之间引入`隐含的耦合性`，在使用中要格外小心；

# 不变性
1. 不可变对象一定是线程安全的；
2. 不可变对象很简单。他们只有一种状态，并且该状态由构造函数来控制；
3. 不可变对象仍然是可变的，因为在final类型的域中可以保存对可变对象的引用；
当满足以下条件时，对象才是不可变的：
1. 对象创建以后其状态就不能修改；
2. 对象的所有域都是final类型；
3. 对象是正确创建的（在对象的创建期间，this引用没有溢出）；

## Final域
1. final域用于构建不可变对象；
2. final类型的域是不能修改的；
3. 如果final域引用的对象是可变的，那么这些被对象引用的对象是可以修改的；
4. java内存模型中，final域能确保`初始化过程`中的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时`无需同步`；
>编程习惯
1. 除非需要更高的可见性，否则应将所有域都声明为private域;
2. 除非需要某个域是可变的，否则应将其声明为final域；

## 使用Volatile类型来发布不可变对象
1. 对于在访问和更新多个相关变量时出现的竞态条件问题，可以通过将这些变量全部保存在一个`不可变对象`中来消除；
2. 如果是一个可变对象，那么必须通过锁来确保原子性；
3. 如果要`更新`这些变量，那么可以通过创建一个新的`容器对象`，使其他使用原有对象的线程仍然会看到对象处于一致的状态；
4. 通过包含多个状态变量的`容器`对象来维持`不可变对象`；
并可使用一个`volatile`类型的引用来确保`可见性`；

# 安全发布
## 不正确的发布：正确的对象被破坏
1. 不能指望一个未被完全创建的对象拥有完整性；
2. 没有使用同步来确保对象对其他线程可见，称之为未被正确的发布；
3. 如果没有足够的同步，那么当多个线程间共享数据时将会发生一些非常奇怪的事情。

## 不可变对象与初始化安全性
1. Java内存模型为不可变对象的共享提供了一种特殊的初始化安全保证；
2. 为了维持初始化安全的保证，必须满足不可变性的所有需求：
    * 状态不可修改；
    * 所有域都是final类型；
    * 正确的构造过程；
    
## 安全发布的常用模式
一个正确构造的对象可以通过以下方式来安全的发布：
1. 在`静态初始化函数`中初始化一个对象引用；
2. 将对象的引用保存到`volatile类型的域`或者`AtomicRefrence对象`中；
3. 将对象的引用保存到某个正确构造对象的`final类型域`中；
4. 将对象的引用保存到一个由`锁保护的域`中；

## 事实不可变对象
1. 如果对象在技术上来看是可变的，但其状态在发布后就不会再改变，那么把这种对象称之为`事实不可变对象`（Effectively Immutable Object）;
2. EIO可以简化开发过程，减少同步从而提高性能；

## 可变对象
1. 如果对象在构造后可以修改，那么安全发布只能确保`发布当时`状态的可见性；
2. 对于可变对象，不仅在`发布对象`时要进行同步，而且在每次`对象访问时`同样使用同步来确保后续`修改操作的可见性`;
3. 要安全的共享可变对象，这些对象必须被安全的发布，且必须是线程安全的或者由某个锁保护起来；

>对象的发布需求取决于它的可变性：
>1. 不可变对象可以通过任意机制来发布；
>2. 事实不可变对象必须通过安全方式来发布；
>3. 可变对象必须通过安全方式来发布，且必须是线程安全的或者由某个锁保护起来；

## 安全的共享对象
当获得某个对象之前，你需要知道在这个引用上可以执行哪些操作。
* 在使用它之前是否需要获取一把锁？
* 是否可以修改它的状态？
* 或者只能读取它？

1. 许多并发错误都是由于没有了解共享对象这些`既定规则`而导致的；
2. 当发布一个对象时，必须明确的说明对象的访问方式；
3. 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
* `线程封闭`：只限线程内部修改；
* `只读共享`：无需同步，包括不可变对象和事实不可变对象；
* `线程安全共享`：线程安全的对象在其内部实现同步，外部访问无需同步；
* `保护对象`：被保护的对象只能通过持有`特定的锁`来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象；