性能与可伸缩性
---
1. 线程的最主要的目的是提高程序的运行性能。线程可以使程序更加充分的发挥系统的可用处理能力，从而提高系统的资源利用率。
2. 此外，线程还可以使程序在运行现有任务的情况下立即开始处理新的任务，从而提高系统的响应性；

1. 本章将介绍各种分析、监测以及提升并发程序性能的技术，
2. 但许多提升性能的技术同样会增加`复杂性`，因此也就增加了在`安全性`和`活跃性`上发生失败的风险；
3. 更糟糕的是，虽然某些技术的初衷是`提升性能`，但事实上缺最终于最初的目标背道而驰，或者又带来了其他的`新的性能问题`；
4. 虽然我们希望获得更好的性能，提升性能总会令人满意，但始终要把`安全性`放在第一位；
5. 首先要保证程序能`正确运行`，然后仅当程序的`性能需求`和测试结果要求程序执行得更快时，才应该设法提高它的运行速度；
6. 在设计并发的应用程序时，最主要的考虑因素通常不是将程序的性能提升至极限；

# 对性能的思考
>提升性能意味着用更少的资源做更多的事情。
1. `资源`的含义很广：对于一个给定的操作，通常会缺乏某种特定的资源：如`CPU时钟周期`、`内存`、`网络带宽`、`I/O带宽`、`数据库请求`、`磁盘空间`以及其他资源。
2. 当操作性能由于`某种特定的资源`而受到限制时，我们通常将该操作称为`资源密集型的操作`，例如，`CPU密集型`、`数据库密集型`等；
3. 尽管使用多个线程的目标是提升整体性能，但与单线程相比，多线程总会引入一些`额外的开销`：`线程之间的协调`（如加锁、触发信号以及内存同步等），增加的`上下文切换`，`线程的创建与销毁`，以及`线程的调度`等。
4. 如果过度的使用线程，那么这些`开销`甚至会超过由于提高`吞吐量`、`响应性`或者`计算能力`所带来的性能提升；

## 性能与可伸缩性
## 评估各种性能权衡因素
1. 避免不成熟的优化。首先使程序正确，然后提供运行速度；
2. 在使某个方案比其他方案`更快`之前，首先问自己一些问题：
   1. `更快`的含义是什么?
   2. 该方法在什么`条件`下运行更快？在低负载还是高负载情况下，大数据集还是小数据集？能否通过测试结果来验证你的答案？
   3. 这些条件在运行环境中的发生频率？能否通过测试结果来验证你的答案？
   4. 在其让不同条件的环境中能否使用这里的代码？
   5. 在实现这种性能提升时需要付出哪些隐含的代价，例如增加开发风险或维护开销？这种权衡是否合适？
3. 对性能的提升可能是并发错误的最大来源；
4. 由于并发错误是最难追踪和消除的错误，因此对于任何可能会引入这类的错误的措施，都需要谨`慎实施`；
5. 在对性能进行调优时，一定要有`明确的性能需求`；
6. `以测试为基准，不要猜测`；

# Amdahl定律
1. 在有些问题中，如果可用资源越多，那么问题的解决速度就越快；例如参与收割庄稼的工人越多，那么就能越快的完成收割工作；
2. 有些任务本质上是串行的，例如即使增加再多的工人也不能增加作物的生长速度；
3. 如果使用线程主要是为了发挥多个处理器的处理能力，那么就必须对问题进行合理的并行分解，并使得程序能有效的使用这种潜在的并行能力；
4. 大多数并发程序都与农业耕作有着许多相似之处；他们都是由一系列的并行工作和串行工作组成的；
5. Amdahl定律描述的是：在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中`可并行组件`与`串行组件`所占的比重。假定`F`是必须被串行执行的那部分，那么根据Amdahl定律，在包含`N`个处理器的机器中，最高加速比为：`speedup <= 1/(F+(1-F)/N)`；
6. 当N趋近于∞时，最大加速比趋近于`1/F`;
7. 

## 示例：在各种框架中隐藏的串行部分
## Amdahl定律的应用

# 线程引入的开销
## 上下文切换
## 内存同步
## 阻塞

# 减少锁的竞争
## 缩小所的范围（快进快出）
## 缩小锁的粒度
## 锁分段
## 避免热点域
## 一些替代独占锁的方法
## 监测CPU的利用率
## 向对象池说No

# 示例：比较Map的性能
# 减少上下文切换的开销