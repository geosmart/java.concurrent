性能与可伸缩性
---
1. 线程的最主要的目的是提高程序的运行性能。线程可以使程序更加充分的发挥系统的可用处理能力，从而提高系统的资源利用率。
2. 此外，线程还可以使程序在运行现有任务的情况下立即开始处理新的任务，从而提高系统的响应性；

1. 本章将介绍各种分析、监测以及提升并发程序性能的技术，
2. 但许多提升性能的技术同样会增加`复杂性`，因此也就增加了在`安全性`和`活跃性`上发生失败的风险；
3. 更糟糕的是，虽然某些技术的初衷是`提升性能`，但事实上缺最终于最初的目标背道而驰，或者又带来了其他的`新的性能问题`；
4. 虽然我们希望获得更好的性能，提升性能总会令人满意，但始终要把`安全性`放在第一位；
5. 首先要保证程序能`正确运行`，然后仅当程序的`性能需求`和测试结果要求程序执行得更快时，才应该设法提高它的运行速度；
6. 在设计并发的应用程序时，最主要的考虑因素通常不是将程序的性能提升至极限；

# 对性能的思考
>提升性能意味着用更少的资源做更多的事情。
1. `资源`的含义很广：对于一个给定的操作，通常会缺乏某种特定的资源：如`CPU时钟周期`、`内存`、`网络带宽`、`I/O带宽`、`数据库请求`、`磁盘空间`以及其他资源。
2. 当操作性能由于`某种特定的资源`而受到限制时，我们通常将该操作称为`资源密集型的操作`，例如，`CPU密集型`、`数据库密集型`等；
3. 尽管使用多个线程的目标是提升整体性能，但与单线程相比，多线程总会引入一些`额外的开销`：`线程之间的协调`（如加锁、触发信号以及内存同步等），增加的`上下文切换`，`线程的创建与销毁`，以及`线程的调度`等。
4. 如果过度的使用线程，那么这些`开销`甚至会超过由于提高`吞吐量`、`响应性`或者`计算能力`所带来的性能提升；

## 性能与可伸缩性
## 评估各种性能权衡因素
1. 避免不成熟的优化。首先使程序正确，然后提供运行速度；
2. 在使某个方案比其他方案`更快`之前，首先问自己一些问题：
   1. `更快`的含义是什么?
   2. 该方法在什么`条件`下运行更快？在低负载还是高负载情况下，大数据集还是小数据集？能否通过测试结果来验证你的答案？
   3. 这些条件在运行环境中的发生频率？能否通过测试结果来验证你的答案？
   4. 在其让不同条件的环境中能否使用这里的代码？
   5. 在实现这种性能提升时需要付出哪些隐含的代价，例如增加开发风险或维护开销？这种权衡是否合适？
3. 对性能的提升可能是并发错误的最大来源；
4. 由于并发错误是最难追踪和消除的错误，因此对于任何可能会引入这类的错误的措施，都需要谨`慎实施`；
5. 在对性能进行调优时，一定要有`明确的性能需求`；
6. `以测试为基准，不要猜测`；

# Amdahl定律
1. 在有些问题中，如果可用资源越多，那么问题的解决速度就越快；例如参与收割庄稼的工人越多，那么就能越快的完成收割工作；
2. 有些任务本质上是串行的，例如即使增加再多的工人也不能增加作物的生长速度；
3. 如果使用线程主要是为了发挥多个处理器的处理能力，那么就必须对问题进行合理的并行分解，并使得程序能有效的使用这种潜在的并行能力；
4. 大多数并发程序都与农业耕作有着许多相似之处；他们都是由一系列的并行工作和串行工作组成的；
5. Amdahl定律描述的是：在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中`可并行组件`与`串行组件`所占的比重。假定`F`是必须被串行执行的那部分，那么根据Amdahl定律，在包含`N`个处理器的机器中，最高加速比为：`speedup <= 1/(F+(1-F)/N)`；
6. 当N趋近于`∞`时，最大加速比趋近于`1/F`;
7. Amdahl定律量化了串行化的效率开销。
   * 在拥有10个处理器的系统中，如果程序中有10%的部分需要串行执行，那么最高的加速比为5.3（53%的使用率）；
   * 在拥有100个处理器的系统中，加速比可以达到9.2（9%的使用率）；
   * 即使拥有无限多的CPU，加速比也不可能是10；
8. 要预测应用程序在某个多处理器系统中将实现多大的加速比，还要找出任务中的串行部分；

## 示例：在各种框架中隐藏的串行部分
1. 要想知道串行部分如何隐藏在应用程序的框架中，可以比较当增加线程时`吞吐量的变化`，并根据观察到的可伸缩性变化来推断串行部分中的差异；
2. Synchronized LinkedList采用`单个锁`来保护整个队列的状态，并且在offer和remove等方法的调用期间都将持有这个锁，整个队列的插入或删除操作都将串行执行;
3. ConcurrentLinkedQueue使用了一种更复杂的`非阻塞队列算法`，该算法使用`原子引用`来更新各个链接指针，只有对指针的更新操作时候需要串行执行；

## Amdahl定律的应用
1. 在评估一个算法时，要考虑算法在数百个或数千个处理器的情况下的性能表现，从而对可能出现的伸缩性局限有一定程度的认识；
2. 锁分解（将1个锁分解为2个锁）并不能充分利用多处理器的能力；
3. 锁分段（将1个锁分解为多个锁）可随着处理器数量的增加而增加；

# 线程引入的开销
1. 单线程程序即不存在线程调度，也不存在同步开销，而且不需要使用锁来保证数据结构的一致性；
2. 在多个线程的调度和协调过程中都需要一定的性能开销；
3. 对于为了提升性能而引入的线程来说，并行带来的`性能提升`必须超过并发导致的`开销`；

## 上下文切换
1. 如果主线程是唯一的线程，那么它基本上不会被调度出去；
2. 如果可运行的线程数大于CPU数，那么操作系统最终会将某个正在运行的线程调度出来，从而使其他线程能够使用CPU，这将导致一次上下文切换；
3. 在这个过程中将保存当前运行线程的执行上下文，并将新调度进来的线程的执行上下文设置为当前上下文；
4. 当线程由于等待某个发生竞争的锁而被阻塞时，JVM通常会将这个线程挂起，并允许它被交换出去。如果线程频繁的发生阻塞，那么它们将无法使用完整的调度时间片；
5. 在程序中发生越多的阻塞（包括I/O阻塞，等待获取发生竞争的锁，或者在条件变量上等待），与CPU密集型程序就会发生越多的上下文切换，从而增加调度开销，并因此降低吞吐量；
6. 无阻塞算法有助于减小上下文切换；
7. 大多数通用的处理器中，上下文切换的开销相当于5000-10000个时钟周期，也就是几微秒；

## 内存同步

## 阻塞

# 减少锁的竞争
## 缩小所的范围（快进快出）
## 缩小锁的粒度
## 锁分段
## 避免热点域
## 一些替代独占锁的方法
## 监测CPU的利用率
## 向对象池说No

# 示例：比较Map的性能
# 减少上下文切换的开销