对象的组合
---
>介绍一些组合模式，使一个类更容易成为线程安全的，并且在维护这些类时不会无意破坏类的安全性保证。
<!-- TOC -->

- [设计线程安全的类](#设计线程安全的类)
    - [收集同步的需求](#收集同步的需求)
    - [依赖状态的操作](#依赖状态的操作)
    - [状态的所有权](#状态的所有权)
- [实例封闭](#实例封闭)
    - [Java监视器模式](#java监视器模式)
    - [示例：车辆追踪](#示例车辆追踪)
- [线程安全性的委托](#线程安全性的委托)
    - [示例：基于委托的追踪器](#示例基于委托的追踪器)
    - [独立的状态变量](#独立的状态变量)
    - [当状态失效时](#当状态失效时)
    - [发布底层的状态变量](#发布底层的状态变量)
    - [示例：发布状态的车辆追踪器](#示例发布状态的车辆追踪器)
- [在现有的线程安全类中添加功能](#在现有的线程安全类中添加功能)
    - [客户端加锁机制](#客户端加锁机制)
    - [组合](#组合)
- [将同步策略文档化](#将同步策略文档化)

<!-- /TOC -->
# 设计线程安全的类
在设计线程安全类的过程中，需要包含以下三个基本要素：
1. 找出构成`线程状态`的所有变量；
2. 找出约束状态变量的`不可变条件`；
3. 建立对象状态的`并发访问管理策略`；

* 同步策略（Synchronization Policy）定义了如何在不违背对象不变条件或后验条件的情况下对状态的访问操作进行协同；
* 同步策略规定了如何将`不可变性`、`线程封闭`与`加锁机制`等结合起来以维护线程的安全性，并且还规定了哪些变量由那些锁来保护。

## 收集同步的需求
1. 要确保类的线程安全性，就需要确保它的不变形条件不会在并发访问的情况下被破坏；
2. 对象与变量都有一个状态空间，即所有可能的取值；
3. 状态空间越小，就越容易判断线程的状态；
4. final类型的域用的越多，越能简化对象可能状态的分析过程；

如果不了解对象的不变性与后验条件，那么就不能确保线程安全性。
要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。

## 依赖状态的操作
1. 类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的；
在某些方法中还包含了一些基于状态的`先验条件`（Precondition），如不能从空队列中移除一个元素；
2. 如果在某个操作中包含基于状态的先验条件，这个操作称为以来状态的操作；
3. 在Java中，等待某个条件为真的各种内置机制（包括等待和通知机制）都与内置锁机制紧密关联；
4. 要想实现摸个等待先验条件为真时才执行的操作，一个更简单的方法是通过现有库中的类（如BlockingQueue或Semaphore）来实现依赖状态的行为；
## 状态的所有权
1. 在定义哪些便利将构成对象的状态时，只考虑对象拥有的数据；所有权（Ownership）在Java中并没有得到充分的体现，而是属于类设计中的一个要素；
2. Java的垃圾回收机制使我们避免了如何处理所有权的问题；
3. 许多情况下，所有权与`封装性`总是相互关联的：对象封装它拥有的状态，反之，对它封装的状态拥有所有权；
4. 所有权即控制权，状态变量的所有者将决定采用何种`加锁协议`来维持变量状态的完整性。
5. 发布了某个可变对象的引用，那么不再拥有独立控制权，最多是`共享控制权`；
6. 容器通常表现出一种`所有权分离`的形式，其中容器类拥有其自身的状态，客户端代码则拥有容器中各个对象的状态；如Servlet框架中的ServletContext;

# 实例封闭
## Java监视器模式
## 示例：车辆追踪

# 线程安全性的委托
## 示例：基于委托的追踪器
## 独立的状态变量
## 当状态失效时
## 发布底层的状态变量
## 示例：发布状态的车辆追踪器

# 在现有的线程安全类中添加功能
## 客户端加锁机制
## 组合

# 将同步策略文档化
