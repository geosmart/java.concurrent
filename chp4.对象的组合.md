对象的组合
---
>介绍一些组合模式，使一个类更容易成为线程安全的，并且在维护这些类时不会无意破坏类的安全性保证。
<!-- TOC -->

- [设计线程安全的类](#设计线程安全的类)
    - [收集同步的需求](#收集同步的需求)
    - [依赖状态的操作](#依赖状态的操作)
    - [状态的所有权](#状态的所有权)
- [实例封闭](#实例封闭)
    - [Java监视器模式](#java监视器模式)
    - [示例：车辆追踪](#示例车辆追踪)
- [线程安全性的委托](#线程安全性的委托)
    - [示例：基于委托的追踪器](#示例基于委托的追踪器)
    - [独立的状态变量](#独立的状态变量)
    - [当状态失效时](#当状态失效时)
    - [发布底层的状态变量](#发布底层的状态变量)
    - [示例：发布状态的车辆追踪器](#示例发布状态的车辆追踪器)
- [在现有的线程安全类中添加功能](#在现有的线程安全类中添加功能)
    - [客户端加锁机制](#客户端加锁机制)
    - [组合](#组合)
- [将同步策略文档化](#将同步策略文档化)

<!-- /TOC -->
# 设计线程安全的类
在设计线程安全类的过程中，需要包含以下三个基本要素：
1. 找出构成`线程状态`的所有变量；
2. 找出约束状态变量的`不可变条件`；
3. 建立对象状态的`并发访问管理策略`；

* 同步策略（Synchronization Policy）定义了如何在不违背对象不变条件或后验条件的情况下对状态的访问操作进行协同；
* 同步策略规定了如何将`不可变性`、`线程封闭`与`加锁机制`等结合起来以维护线程的安全性，并且还规定了哪些变量由那些锁来保护。

## 收集同步的需求
1. 要确保类的线程安全性，就需要确保它的不变形条件不会在并发访问的情况下被破坏；
2. 对象与变量都有一个状态空间，即所有可能的取值；
3. 状态空间越小，就越容易判断线程的状态；
4. final类型的域用的越多，越能简化对象可能状态的分析过程；

如果不了解对象的`不变性`与`后验条件`，那么就不能确保线程安全性。
要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于`原子性`与`封装性`。

## 依赖状态的操作
1. 类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的；
在某些方法中还包含了一些基于状态的`先验条件`（Precondition），如不能从空队列中移除一个元素；
2. 如果在某个操作中包含基于状态的先验条件，这个操作称为依赖状态的操作；
3. 在Java中，等待某个条件为真的各种内置机制（包括等待和通知机制）都与`内置锁机制`紧密关联；
4. 要想实现摸个等待先验条件为真时才执行的操作，一个更简单的方法是通过现有库中的类（如BlockingQueue或Semaphore）来实现依赖状态的行为；
## 状态的所有权
1. 在定义哪些便利将构成对象的状态时，只考虑对象拥有的数据；所有权（Ownership）在Java中并没有得到充分的体现，而是属于`类设计`中的一个要素；
2. Java的垃圾回收机制使我们避免了如何处理所有权的问题；
3. 许多情况下，所有权与`封装性`总是相互关联的：对象封装它拥有的状态，反之，对它封装的状态拥有所有权；
4. 所有权即控制权，状态变量的所有者将决定采用何种`加锁协议`来维持变量状态的完整性。
5. 发布了某个可变对象的引用，那么不再拥有独立控制权，最多是`共享控制权`；
6. 容器通常表现出一种`所有权分离`的形式，其中容器类拥有其自身的状态，客户端代码则拥有容器中各个对象的状态；如Servlet框架中的ServletContext;

# 实例封闭
如果某对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全的使用。
* 确保该对象只能由单个线程访问（线程封闭）；
* 通过一个锁来保护该对象的所有访问；

1. `封装`简化了线程安全类的实现过程，它提供了一种实例封闭机制（Instance Confinement），通常也称为'封闭'；
2. 当一个对象被封装到另一个对象中时，能够访问被封装对象的所有代码路径都是已知的，与对象可以由整个程序访问的情况相比，更易于对代码进行分析；
3. 通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象；
4. JDK中有很多线程封闭的示例，其中有些类的唯一与就是将`非线程安全的类转换为线程安全的类`：
如ArrayList和HashMap，但JDK提供了包装器工厂方法，如`Collections.synchronizedList`；

>将数据封装在对象内部，可以将数据的访问限制在`对象的方法`上，从而更容易确保线程在访问数据时总能`持有正确的锁`；
>`封闭机制`更易于构建线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无需检查整个程序;

## Java监视器模式
从线程封闭原则及其逻辑推论可以得出Java监视器模式；

## 示例：车辆追踪
MVC：模型由一个视图线程和多个执行更新操作的线程共享；

# 线程安全性的委托
将线程安全性委托给它的线程安全变量，如Atomic变量

## 示例：基于委托的追踪器
## 独立的状态变量
## 当状态失效时
1. 如果某个类含有`复合操作`，那么仅靠委托并不足以实现线程安全性。在这种情况下，这个类必须提供自己的`加锁机制`以保障这些复合操作都是`原子操作`，除非整个复合操作都可以委托给状态变量；
2. 如果一个类是由多个`独立`且线程安全的状态变量组成，并且在所有操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量；

## 发布底层的状态变量
如果一个状态变量是`线程安全`的，并且没有任何`不变性条件`约束它的值，在变量的操作上也不存在任何不允许的情况，那么就可以安全的发布这个变量；

## 示例：发布状态的车辆追踪器
getLocations():unmodifiableMap(ConcurrentHashMap)

# 在现有的线程安全类中添加功能
put-if-absent操作，用锁来保证原子性

## 客户端加锁机制
1. 客户端加锁是指，对于某个对象X的`客户端代码`，使用X`本身用于保护其状态的锁`来保护这段客户代码；
2. 要使用客户端加锁，你必须知道对象X使用的是哪一个锁；
```java
@NotThreadSafe
public class ListHelper<E>{
    public List<E> list=Collections.synchronizedList(new ArrayList<E>());
    //相对于其他list的操作并不是原子的
    public synchronized boolean putIfAbsent(E x){
        boolean absent=!list.contains(x);
        if(absent){
            list.add(x);
        }
        return absent;
    } 
}
```
非线程安全，在错误的锁上进行了同步...

```java
@ThreadSafe
public class ListHelper<E>{
    public List<E> list=Collections.synchronizedList(new ArrayList<E>());
    //相对于其他list的操作并不是原子的
    public  boolean putIfAbsent(E x){
        synchronized(list){
            boolean absent=!list.contains(x);
            if(absent){
                list.add(x);
            }
            return absent;
        }
    } 
}
```
1. 通过添加一个`原子操作`来扩展类是脆弱的，因为它将类的`加锁代码`分布到多个类中；
2. 通过客户端加锁更加脆弱，当在哪些并不承诺遵循加锁策略的类上使用客户端加锁时要特别小心；
3. 客户端加锁机制与扩展类机制有许多共同点，二者都是将派生类的行为与基类的实现耦合在一起；
4. 正如扩展会破坏实现的封装性，客户端加锁也会破坏同步策略的封装性；
## 组合

# 将同步策略文档化
