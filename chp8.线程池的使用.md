线程池的使用
---
本章介绍对线程池进行配置与调优的一些高级选项，并分析在使用任务执行框架时需要注意的各种危险，以及一些使用Executor的高级示例。

<!-- TOC -->

- [在任务与执行策略之间的隐性耦合](#在任务与执行策略之间的隐性耦合)
    - [线程饥饿死锁（Thread Starvation Deallock）](#线程饥饿死锁thread-starvation-deallock)
    - [运行时间较长的任务](#运行时间较长的任务)
- [设置线程池的大小](#设置线程池的大小)
- [配置ThreadPoolExecutor](#配置threadpoolexecutor)
    - [线程的创建和销毁](#线程的创建和销毁)
    - [管理队列任务](#管理队列任务)
    - [饱和策略](#饱和策略)
    - [线程工厂](#线程工厂)
    - [在调用构造函数后再定制ThreadPoolExecutor](#在调用构造函数后再定制threadpoolexecutor)
- [扩展ThreadPoolExecutor](#扩展threadpoolexecutor)
- [递归算法的并行化](#递归算法的并行化)
- [小结](#小结)

<!-- /TOC -->

# 在任务与执行策略之间的隐性耦合
并非所有任务都能够以Executor框架将提交与执行策略解耦，有些类型的任务需要明确的指定执行策略：
1. 依赖性任务：注意`活跃性问题`；
2. 使用线程封闭机制的任务：任务要求其执行所在的Executor是单线程的；
3. 对响应时间敏感的任务：GUI程序；
## 线程饥饿死锁（Thread Starvation Deallock）
1. 在线程池中，如果任务以来于其他任务，那么可能产生死锁；
2. 在单线程Executor中，如果一个任务将另一个任务提交到同一个Executor，并且等待这个被提交任务的结果，那么通常会引发死锁；
3. 在更大的线程池中，如果所有正在执行的线程都由于等待其他仍处于工作队列中的任务而阻塞，那么会发生`线程饥饿死锁`；
4. 只要线程池中的任务需要无限期的等待一些必须由池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或结果，那么除非线程池足够大，否则将发生线程饥饿死锁；

>饥饿死锁示例
```java
public class ThreadDeadLock{
    ExecutorService exec=Executors.newSingleThreadPoolExecutor();
    
    public class RenderPageTask implements Callable<String>{
        public String call()throws Exception{
            Future<String> header,footer;
            header=exec.submit(new LoadFileTask("header.html"));
            footer=exec.submit(new LoadFileTask("footer.html"));
            String page =renderBody();
            //将发生死锁--由于等待子任务的结果
            return header.get()+page+footer.get();
        }
    }
}
```
每当提交一个有依赖性的Executor任务时，需要清楚的知道可能会出现线程`饥饿死锁`，因此需要在代码或配置Executor的配置文件中记录线程池的大小现在或配置限制；

## 运行时间较长的任务
1. 如果任务阻塞的时间过长，那么即使不出现死锁，线程池的响应性也会变得很糟；
2. 执行时间较长的任务不仅会造成线程池阻塞，甚至会增加执行时间较短任务的服务时间；
3. 限定任务等待资源时间可以缓解执行时间较长任务造成的影响，而不需要无限制的等待；
4. Thread.join，BlocingQueue.put，CountdownLatch.await以及Selector.select等都定义了限时版本和无限时版本；
5. 如果等待超时，那么可以将任务标识为失败，然后中止任务或将任务重新放回队列以便随后执行。
6. 如果线程池中总是充满了被阻塞的任务，那么也可能表明线程池的规模过小；

# 设置线程池的大小
1. 线程池的理想大小取决于被提交`任务的类型`以及所部署`系统的特性`；
2. 一般通过某种配置机制来设置线程池的大小，或通过`Runtime.getRuntime().availableProcessors()`来动态计算；
3. 要合理设置线程池的大小，需要避免`极大`和`过小`这两种极端情况：
    * 如果线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能耗尽资源；
    * 如果线程池过小，那么将导致许多空闲的处理器无法执行工作，从而降低吞吐率；
4. 要想正确的设置线程池的大小，必须分析计算环境、资源预算和任务的特性。
    * 在部署的系统中有多少个CPU？多大内存？
    * 任务是`计算密集型`、`I/O密集型`还是二者皆可？
    * 他们是否需要像JDBC连接这样的稀缺资源？
5. 如果需要`执行不同类别的任务`，并且他们之间的行为相差很大，那么应该考虑使用多个线程池，从而为每个线程池可以根据各自的工作负载来调整；
6. 对于计算密集型的任务，在拥有N个CPU的系统上，当线程池的大小为N+1，通常能实现最优的利用率；即当计算密集型的线程偶尔由于页缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费；
7. 对于包含I/O操作或者其他阻塞操作的任务，由于线程并不会一直运行，因此线程池的规模应该更大；
8. 要正确的设置线程池的大小，必须估算出任务的等待时间与计算时间的比值；这种估算不需要很精确，并且可以通过一些分析或监控工具来获得；
9. 要使处理器达到期望的使用率，线程池的最优大小等于：`N_thread=N_cpu*U_cpu*(1+W/C)`
    * N_cpu：cpu个数，Runtime.getRuntime().availableProcessors()；
    * U_cpu：目标cpu利用比例，(U_cpu取值范围[0,1])；
    * W/C：任务等待时间与计算时间的比例；
10. CPU周期并不是唯一影响线程池大小的资源，还包括内`存、文件句柄、套接字句柄和数据库连接`等。计算这些资源对线程池的约束条件是更容易的：`线程池大小的上限=该资源的可用总量/每个任务的需求量`

# 配置ThreadPoolExecutor
## 线程的创建和销毁
## 管理队列任务
## 饱和策略
## 线程工厂
## 在调用构造函数后再定制ThreadPoolExecutor

# 扩展ThreadPoolExecutor

# 递归算法的并行化

# 小结